# -*- coding: utf-8 -*-
"""
Created on Wed Jul 22 12:25:03 2020

@author: Derek Joslin
"""

import TactileTweener
import numpy as np


class HapticsEngine:

    #haptics engine takes in physics of a board and properly executes graphical commands based on the physics
    #take in the physics of the fluidic chip from matlab and use that to determine timing for actions
    #maybe have it take in an FC library class

    def __init__(self, tpw, th, ts, rows, columns, refreshProtocol):
        self.__tpw = tpw
        self.__th = th
        self.__ts = ts
        self.__rows = rows
        self.__columns = columns
        self.__currentState = [[None for i in range(0,columns)] for j in range(0,rows)]
        self.__desiredState = [[None for i in range(0,columns)] for j in range(0,rows)]
        self.__refreshInfo = {'refresh protocol': refreshProtocol}
        #calculate how fast each element in the chip updates based on the setup, hold, and pulse width of the element
        elementTiming = (np.array(ts) + np.array(th)).tolist()
        for rowIndex, row in enumerate(elementTiming):
            for columnIndex, element in enumerate(row):
                if element < tpw[rowIndex][columnIndex]:
                    element = tpw[rowIndex][columnIndex]
                
        self.__refreshInfo.update({'element refresh timing' : elementTiming})

    def get_state(self):
        return self.__currentState

    #returns dictionary with all important transformation info
    def get_refreshInfo(self):
        return self.__refreshInfo

    #creates the frames and to get from current state to desired state
    def refresh_chip(self):
        #create a tweener to get the frames to get to the desired state
        tt = TactileTweener.TactileTweener()
        
        
        #Matrices to transform
        self.__currentState = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]]

        self.__desiredState = [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, ],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 ]]


        #tween the frames
        refreshFrames = tt.get_tweenFrames(self.__currentState, self.__desiredState, self.__refreshInfo['refresh protocol'])

        #set the current time to 0
        currentTime = 0

        #calculate the time when each element will refresh for each frame
        elementTiming = self.__refreshInfo['element refresh timing']
        timeMatrix = [[0 for i in range(0,self.__columns)] for j in range(0,self.__rows)]
        
        x = 0
        highest = 0
        for index, frame in enumerate(refreshFrames):
            for rowIndex, row in enumerate(frame['element change']):
                for columnIndex, elementChange in enumerate(row):
                    if elementChange == True:
                        timeMatrix[rowIndex][columnIndex] = timeMatrix[rowIndex][columnIndex] + elementTiming[rowIndex][columnIndex] + highest
            if highest < (max(map(max, timeMatrix))):
                highest = (max(map(max, timeMatrix)))
            display_frame(frame['state'], frame['element change'], timeMatrix, x)
            x += 1
            refreshFrames[index].update({'timing data': timeMatrix.copy()})
            timeMatrix = timeMatrix.copy()
        
        self.__refreshInfo.update({'frame info': refreshFrames})



    def set_refreshProtocol(self,protocol):
        self.__refreshInfo['refresh protocol'] = protocol


    def get_timeFrame(self, time):
        """At a certain time(in milliseconds) show what the state would look like at that time"""
        #search through the timing data in frame by frame info and find the first frame with a higher timing data value than time
        for frameIndex,frame in enumerate(self.__refreshInfo['frame info']):
            for rowIndex,row in enumerate(frame['timing data']):
                for column,changeTime in enumerate(row):
                    if changeTime < time:
                        #get the frame before and the current frame
                        beforeFrame = self.__refreshInfo['frame info'][frameIndex - 1]
                        currentFrame = self.__refreshInfo['frame info'][frameIndex]
                         #set the appropriate value equal to the current state
                         if currentFrame['timing data'][rowIndex][columnIndex] < time:
                             self.__currentState[rowIndex][columnIndex] = currentFrame['state'][rowIndex][columnIndex]
                         else:
                             self.__currentState[rowIndex][columnIndex] = beforeFrame['state'][rowIndex][columnIndex]
# =============================================================================
#                         #loop through current frame and put in the appropriate value
#                         for rowIndex,row in enumerate(self.__currentState):
#                             for columnIndex,element in enumerate(row):
#                                 #set the appropriate value equal to the current state
#                                 if currentFrame['timing data'][rowIndex][columnIndex] < time:
#                                     self.__currentState[rowIndex][columnIndex] = currentFrame['state'][rowIndex][columnIndex]
#                                 else:
#                                     self.__currentState[rowIndex][columnIndex] = beforeFrame['state'][rowIndex][columnIndex]
# =============================================================================
                        display_frame(self.__currentState, currentFrame['element change'], currentFrame['timing data'], frameIndex)
        

def display_frame(state, element_change, timing_data, number):
    print('frame: {0}'.format(number))
    print('---------------------------\n\r')
    print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
                     for row in state]))
    print('T/F')
    print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
                     for row in element_change]))
    print('timing data')
    print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
                     for row in timing_data]))



