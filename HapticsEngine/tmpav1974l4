# -*- coding: utf-8 -*-
"""
Created on Wed Jul 22 12:25:03 2020

@author: Derek Joslin
"""

import copy
import TactileTweener
import numpy as np


class HapticsEngine:

    #haptics engine takes in physics of a board and properly executes graphical commands based on the physics
    #take in the physics of the fluidic chip from matlab and use that to determine timing for actions
    #maybe have it take in an FC library class

    def __init__(self, tpw, th, ts, rows, columns, refreshProtocol):
        self.__tpw = tpw
        self.__th = th
        self.__ts = ts
        self.__rows = rows
        self.__columns = columns
        self.__currentState = [[0 for i in range(0,columns)] for j in range(0,rows)]
        self.__desiredState = [[0 for i in range(0,columns)] for j in range(0,rows)]
        self.__refreshInfo = {'refresh protocol': refreshProtocol}
        #calculate how fast each element in the chip updates based on the setup, hold, and pulse width of the element
        elementTiming = (np.array(ts) + np.array(th)).tolist()
        for rowIndex, row in enumerate(elementTiming):
            for columnIndex, element in enumerate(row):
                if element < tpw[rowIndex][columnIndex]:
                    element = tpw[rowIndex][columnIndex]
                
        self.__refreshInfo.update({'element refresh timing' : elementTiming})

    def get_currentState(self):
        """ returns the current state of the chip """
        return self.__currentState

    def get_desiredState(self):
        """ returns the state that the chip wants to be in """
        return self.__desiredState

    def set_desiredState(self, newState):
        """ sets a desired state of the chip """
        self.__desiredState = newState.copy()
    
    def set_refreshProtocol(self, protocol):
        """ sets the protocol for refreshing the chip and generating the refresh states """
        self.__refreshInfo['refresh protocol'] = protocol

    def generate_refreshStates(self):
        """ creates the minimum number of frames to get from current state to desired state 
        returns the time it takes to get from current state to desired state """
        uniqueFrames = self.__refreshInfo['unique frame times']
        refreshFrames = []
        for time in uniqueFrames + 1:
            refreshFrames.insert(time, self.__get_timeFrame(time))
            
        self.__refreshInfo.update({'refresh frames' : refreshFrames})
    
        return uniqueFrames
        
    def set_stateTime(self, t):
        """ sets the current state to a point in time t milliseconds after the refresh occurs """ 
        
        
    
# =============================================================================
#     #returns dictionary with all important transformation info
#     def get_refreshInfo(self):
#         return self.__refreshInfo
# =============================================================================

    def __refresh_chip(self):
     """ creates the frames and to get from current state to desired state """
        
        #create a tweener to get the frames to get to the desired state
        tt = TactileTweener.TactileTweener()

        #tween the frames
        refreshFrames = tt.get_tweenFrames(copy.deepcopy(self.__currentState), copy.deepcopy(self.__desiredState), self.__refreshInfo['refresh protocol'])

        #set the current time to 0
        currentTime = 0

        #calculate the time when each element will refresh for each frame
        elementTiming = self.__refreshInfo['element refresh timing']
        timeMatrix = [[currentTime for i in range(0,self.__columns)] for j in range(0,self.__rows)]
        
        x = 0
        highest = 0
        #list for timing of each unique frame
        uniqueFrames = []
        for index, frame in enumerate(refreshFrames):
            for rowIndex, row in enumerate(frame['element change']):
                for columnIndex, elementChange in enumerate(row):
                    if elementChange == True:
                        timeMatrix[rowIndex][columnIndex] = timeMatrix[rowIndex][columnIndex] + elementTiming[rowIndex][columnIndex] + highest
                        uniqueFrames.append(timeMatrix[rowIndex][columnIndex])
            if highest < (max(map(max, timeMatrix))):
                highest = (max(map(max, timeMatrix)))
            #display_frame(frame['state'], frame['element change'], timeMatrix, x)
            x += 1
            refreshFrames[index].update({'timing data': copy.deepcopy(timeMatrix)})
        
        self.__refreshInfo.update({'frame info' : refreshFrames, 'unique frame times' : uniqueFrames})

    def __get_timeFrame(self,time):
        """At a certain time(in milliseconds) show what the state would look like at that time"""
        #search through the timing data in frame by frame info and find the first frame with a higher timing data value than time
        #create a set of frames to store the refresh that occurs
        self.__currentState = copy.deepcopy(self.__refreshInfo['frame info'][0]['state'])
        for frameIndex,frame in enumerate(self.__refreshInfo['frame info']):
            for rowIndex,row in enumerate(frame['timing data']):
                for columnIndex,changeTime in enumerate(row):
                    if (changeTime <= time) and (frameIndex > 0):
                        #get the frame before and the current frame
                        beforeFrame = self.__refreshInfo['frame info'][frameIndex - 1]
                        currentFrame = self.__refreshInfo['frame info'][frameIndex]
                         #set the appropriate value equal to the current state
                        if currentFrame['timing data'][rowIndex][columnIndex] <= time:
                            self.__currentState[rowIndex][columnIndex] = currentFrame['state'][rowIndex][columnIndex]
                        else:
                            self.__currentState[rowIndex][columnIndex] = beforeFrame['state'][rowIndex][columnIndex]
        return self.__currentState



# =============================================================================
#         print('state at time: {0}'.format(time))
#         print('---------------------------\n\r')
#         print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
#                          for row in self.__currentState]))
# =============================================================================
# =============================================================================
#                         #loop through current frame and put in the appropriate value
#                         for rowIndex,row in enumerate(self.__currentState):
#                             for columnIndex,element in enumerate(row):
#                                 #set the appropriate value equal to the current state
#                                 if currentFrame['timing data'][rowIndex][columnIndex] < time:
#                                     self.__currentState[rowIndex][columnIndex] = currentFrame['state'][rowIndex][columnIndex]
#                                 else:
#                                     self.__currentState[rowIndex][columnIndex] = beforeFrame['state'][rowIndex][columnIndex]
# =============================================================================
        
# =============================================================================
# 
# def display_frame(state, element_change, timing_data, number):
#     print('frame: {0}'.format(number))
#     print('---------------------------\n\r')
#     print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
#                      for row in state]))
#     print('T/F')
#     print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
#                      for row in element_change]))
#     print('timing data')
#     print('\n'.join([' '.join(['{:4}'.format(item) for item in row])
#                      for row in timing_data]))
# 
# =============================================================================


